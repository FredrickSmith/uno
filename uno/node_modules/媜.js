
const cry = require ('軞'); // token/id
const F   = require ('sprintf-js').sprintf

//  pick    , cont    , play   , win     , uno     , nouno   , clearuno, nothing
let 闭 = 0x0, 问 = 0x1, 闯 = 0x2, 闰 = 0x3, 闱 = 0x4, 闲 = 0x5, 闳 = 0x6, 间 = 0x7;

let 뿰 = 0x0, 뿱 = 0x1, 뿲 = 0x2, 뿳 = 0x3, 뿴 = 0x4, 뿵 = 0x5, 뿶 = 0x6 , 뿷 = 0x7 , 뿸 = 0x8 , 뿹 = 0x9 ,
//  red		, blue    , green   , yellow , black   , skip    , reverse  , plus2    , plus4   , change   ,
	뿺 = 0xA, 뿻 = 0xB, 뿼 = 0xC, 뿽 = 0xD, 뿾 = 0xE, 뿿 = 0xF, 쀀 = 0x10, 쀁 = 0x11, 쀂 = 0x12, 쀃 = 0x13;

//  p1      , p2      , unknown
let 㔀 = 0x1, 㔁 = 0x2, 㔂 = 0x3;

//  fail    , success
let 陦 = 0x1, 陧 = 0x1;


cardtostring = (c, m = !1) => { // card(s), multiple
	if (m) {
		var s = ''; // string

		for (var n = 0; n < c.length; n++) {
			s += F ('%s|%s|%s>', c [n]._id, c [n]._n, c [n]._t);
		}

		s += '!';

		return s;
	}
	return F ('%s|%s>!', c._n, c._t);
}

class pqCard {
	constructor (n = 'invalid', t = 'invalid', id = !1/*, h = ()=>{return'invalid'}*/) { // name, type, handler
		this._id = id ? id : cry.genid (); // id

		this._n = n; // name
		this._t = t; // type
		// self._h = h; // handler
	}
	edit (k, v) { // key,value
		this [k] = v;
	}
	// play (_) {
		// return this._h (_);
	// }
}

class pqDeck {
	constructor (c = []) { // cards
		this._c = c; // cards
	}

	putdown (c, m = !1) { // cards, multiple
		if (m) {
			for (e in c) { // card
				this._c.unshift (c);
			}
			return;
		}
		this._c.unshift (c);
	}

	pickup (n = false) { // number
		if (n) {
			var c = []; // cards
			for (var _ = 0; _ < n; _++) {
				c.unshift (this._c.shift ());
			}
			return c;
		}
		return this._c.shift ();
	}

	top () {
		return this._c [0];
	}
}

class pqHand {
	constructor (c = []) { // cards
		this._c = c; // cards
	}

	played (c, /*..._*/) { // cardID, !data!
		var o = this._c.slice (c, c + 1)// ,
			// p = this._c [c].play (..._); // card, played
		this._c.splice (c, 1);
		return o;// , p;
	}
	pickedup (c, m = !1) { // card(s), multiple
		if (m) {
			for (var n = 0; n < c.length; n++) { // card
				this._c.unshift (c);
			}
			return [c, m];
		}
		this._c.unshift (c);
		return [c, m];
	}
	get (c) { // cID
		return this._c.slice (c, c + 1);
	}
	edit (c, k, v) { //cID, key, value
		this._c [c].edit (k, v);
	}
}

class pqGame {
	constructor (c, h) { // card list, turn handler
		this._id = ''; // id

		this._cc = c; // current card list
		this._cl = c; // card list

		this._h = {}; // hands
		this._d = []; // decks

		this._th = h; // turn handler

		this._o  = []; // order
		this._oc = this._o.length; // order current

		this._s = false; // skip
		this._r = false; // reverse

		this._u = {}; // uno

		this._pi = !1; // in plus
		this._ps = ~0; // plus stack
		this._pl = -0; // plus last
	}

	set id (id) { // id
		this._id = id
	}
	get id () {
		return this._id
	}

	order (o) { // order
		this._o = o;
	}
	skipped () {
		var s = this._s; // skip
		if (this._s)
			this._s = false;
		return s;
	}
	reversed () {
		var r = this._r; // skip
		if (this._r)
			this._r = false;
		return r;
	}
	nextorder () {
		var m = this.skipped () || this.reversed () ? 0 : (this._oc == 1 ? -1 : 1);

		this._oc += m;
	}

	createhand (id, n) { // id, number
		var h = new pqHand ();
		for (var _ = 0; _ < n; _++) {
			let r = Math.floor (Math.random () * Math.floor (this._cc.length)) - 1; // random

			h.pickedup (this._cc.slice (r, r + 1));

			this._cc.splice (r, 1);
		}

		this._h [id] = h;
	}
	createdeck (n) { // number
		var d = new pqDeck ();
		for (var _ = 0; _ < n; _++) {
			var r = Math.floor (Math.random () * Math.floor (this._cc.length)); // random

			d.putdown (this._cc.slice (r, r + 1));

			this._cc.splice (r, 1);
		}

		this._d.push (d);
	}

	canturn (d) { // data
		return d.id == this._o [this._oc];
	}

	isuno (id) { // id
		return this._u [id];
	}
	uno (id, b) { // id, bool
		this._u [id] = b;
	}

	pickup (d) { // data
		if (this._pi) {
			this._h [d.id].pickedup (this._d [0].pickup (this._ps), true);

			var ps = this._ps
			this._pi = !1; // reset stack
			this._ps = ~0;
			this._pl = -0;
			return ps;
		}

		this._h [d.id].pickedup (this._d [0].pickup (1), true);
		return 1;
	}
	douno (d) { // data
		if (this._h [d.id]._c.length == 2) {
			this.uno (d.id, true);
			return 闲;
		}
		return 闳;
	}


	doturn (d) { // data
		if (!this.canturn (d))
			return [间, 间];

		if (d.un) { // uno
			return [闱, this.douno (d)];
		}

		if (d.pi) { // picking up
			var pu = this.pickup (d);

			this.nextorder ();
			return [闭, pu];
		}

		var [c, p, w, u] = this._th (this, d); // continue, play, win, uno
		if (c)
			return [问, 间];

		if (p) { // played a card
			var o/*, p*/ = this._h [d.id].played (d._p);

			this._d [1].putdown (o);

			this.nextorder ();

			return [闯, u ? u : 闳]; // if uno then uno else nouno
		}
		if (w)
			return [闰, d.id];
	}

	start (ids) { // ids
		var id1 = ids [0];
		var id2 = ids [1];

		this.createhand (id1, 7); // player 1
		this.createhand (id2, 7); // player 2

		this.createdeck (this._cc.length - 1); // main deck
		this.createdeck (1                  ); // used deck

		this.uno (id1, false); // player 1
		this.uno (id2, false); // player 2

		this.order ([id1, id2]); // order

		var r = Math.floor (Math.random () * Math.floor (0xFFF));
		for (var _ = 0; _ < r; _++) {
			this.nextorder ();
		}
	}
}

let th = (g, d) => { // game, data
	c = g._h [d.id].get (d._p); // playing card
	r = g._d [1   ].top ()    ; // graveyard

	if (c._t != 뿾 && c._t != r._t && c._n != r._n) // black check, type check, num check
		return [true, false, false, false];

	if (g._pi && g._pl == 쀂 && c._t == 쀁) // +2 a +4
		return [true, false, false, false];

	u = false
	if (!g.isuno (d.id) && g._h [d.id]._c.length == 2) { // if not call uno and card = 2 before playing give penalty
		u = g._h [d.id].pickedup (g._d [0].pickup (2), true);;
	}
	if (g._h [d.id]._c.length == 1)
		return [false, false, true, false]; // they win if last card passes checks, nothing else needed


	if (c._t == 쀂) { // +4
		g._pi  = true;
		g._pl  = 쀂;
		g._ps += 4;
	}
	if (c._t == 쀁) { // +2
		g._pi  = true;
		g._pl  = 쀂;
		g._ps += 2;
	}

	if (c._t == 쀃) // change
		g._h [d.id].edit (d._p, '_n', d._c);

	if (c._t == 뿿) // skip
		g._s = true;

	if (c._t == 쀀) // reverse
		g._r = true;

	return false, false, true, u;
}

let uno = [ // colour, number
	// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
	//    1, 2, 3, 4, 5, 6, 7, 8, 9
	[뿺, 뿰],	[뿺, 뿱], [뿺, 뿲], [뿺, 뿳], [뿺, 뿴], [뿺, 뿵], [뿺, 뿶], [뿺, 뿷], [뿺, 뿸], [뿺, 뿹], // red numbers
				[뿺, 뿱], [뿺, 뿲], [뿺, 뿳], [뿺, 뿴], [뿺, 뿵], [뿺, 뿶], [뿺, 뿷], [뿺, 뿸], [뿺, 뿹],
	[뿻, 뿰],	[뿻, 뿱], [뿻, 뿲], [뿻, 뿳], [뿻, 뿴], [뿻, 뿵], [뿻, 뿶], [뿻, 뿷], [뿻, 뿸], [뿻, 뿹], // blue numbers
				[뿻, 뿱], [뿻, 뿲], [뿻, 뿳], [뿻, 뿴], [뿻, 뿵], [뿻, 뿶], [뿻, 뿷], [뿻, 뿸], [뿻, 뿹],
	[뿼, 뿰],	[뿼, 뿱], [뿼, 뿲], [뿼, 뿳], [뿼, 뿴], [뿼, 뿵], [뿼, 뿶], [뿼, 뿷], [뿼, 뿸], [뿼, 뿹], // green numbers
				[뿼, 뿱], [뿼, 뿲], [뿼, 뿳], [뿼, 뿴], [뿼, 뿵], [뿼, 뿶], [뿼, 뿷], [뿼, 뿸], [뿼, 뿹],
	[뿽, 뿰],	[뿽, 뿱], [뿽, 뿲], [뿽, 뿳], [뿽, 뿴], [뿽, 뿵], [뿽, 뿶], [뿽, 뿷], [뿽, 뿸], [뿽, 뿹], // yellow numbers
				[뿽, 뿱], [뿽, 뿲], [뿽, 뿳], [뿽, 뿴], [뿽, 뿵], [뿽, 뿶], [뿽, 뿷], [뿽, 뿸], [뿽, 뿹],
	// skip , reverse,  +2     , skip   , reverse , +2
	[뿺, 뿿], [뿺, 쀀], [뿺, 쀁], [뿺, 뿿], [뿺, 쀀], [뿺, 쀁], // red    specials
	[뿻, 뿿], [뿻, 쀀], [뿻, 쀁], [뿻, 뿿], [뿻, 쀀], [뿻, 쀁], // blue   specials
	[뿼, 뿿], [뿼, 쀀], [뿼, 쀁], [뿼, 뿿], [뿼, 쀀], [뿼, 쀁], // green  specials
	[뿽, 뿿], [뿽, 쀀], [뿽, 쀁], [뿽, 뿿], [뿽, 쀀], [뿽, 쀁], // yellow specials
	[뿾, 쀂], [뿾, 쀂], [뿾, 쀂], [뿾, 쀂], // black +4
	[뿾, 쀃], [뿾, 쀃], [뿾, 쀃], [뿾, 쀃]  // black change
], unoo = []
for (var n = 0; n < uno.length; n++) { // quick convert to real cards (data > pqCard)
	var c = uno [n]
	c = new pqCard (c [0], c [1]);
	unoo.push (c);
}
uno = unoo;

let lobbies = {}, curlob = ''; // """matchmaking"""

class pqLobby {
	constructor (b = !1, id = !1) {// bool, id
		this._p1 = !1; // p1 token
		this._p2 = !1; // p2 token

		this._n = {}; // names

		this._gid = id ? id : cry.gentoken (); // gameid

		this._g = ''; // game
		this._d = !1; // done

		lobbies [this._gid] = this;

		this._cl = b; // current lobby?

		return this._gid;
	}

	cards (d) {
		return cardtostring (this._g._h [d.id]._c);
	}

	name (d) {
		var o = this._n [d.id]; // old name
		this._n [d.id] = d.n;
		return [o, d.n];
	}

	done () {
		this._d = true;
		delete this._g; // clear stuff up
	}

	join (t = !1) { // token
		if (this._p2) {
			return [㔂, ''];
		}

		if (!this._p1) {
			this._p1 = t ? t : cry.gentoken ();
		 	this._n [this._p1] = 'p1';
			return [㔀, this._gid];
		}
		this._p2 = t ? t : cry.gentoken ();
		this._n [this._p2] = 'p2';

		return [㔁, this._gid];
	}
	start () {
		if (!this._p2) 
			return [陧, !1];
		this._g = new pqGame (uno, th);

		this._g.start ([this._p1, this._p2]);
		return [陦, this._g._oc];
	}
	push (d) { // data
		return this._g.doturn (d);
	}
}

let nextlobby = () => {
	curlob = new pqLobby (true);
}

let newlobby = lid => { // lobby id
	if (!lobbies [lid] || (lobbies [li] && lobbies [li].d)) {
		new pqLobby (!1, lid);
		return 陦;
	}
	return 陧;
}

exports._ = (i, s, d) => { // io, socket, data

	// what do
	if (d.wd == 'make' && d.l) {
		return s.emit ('m', newlobby (d.l));
	}
	if (!d.l && lobbies [d.l])
		return;

	var l = lobbies [d.l]; // lobby

	if (d.wd == 'name' && d.n) {
		return i.to (d.l).emit ('n', l.name (d.n));
	} else if (d.wd == 'start' && d.l && l) {
		return i.to (d.l).emit ('s', l.start ());
	} else if (d.wd == 'join') {
		var [ja, id] = lobbies [d.l && l && !l.d ? d.l : curlob].join (d.id ? d.id : !1); // join attempt

		s.emit ('j', ja != 㔂 ? id : '>.<');

		return i.to (d.l).emit ('ja', [ja, d.id ? d.id : '>.<']);
	} else if (d.wd == 'give' && !l.d) {
		return s.emit ('c', l.cards ());
	} else if (d.wd == 'play' && !l.d) {
		var [r, d, x] = l.push (d); // result, data, extra

		if (r == 间) { // cant turn
			s.emit ('p', [间]);
			return i.to (d.l).emit ('g', [间, l._n [d.id]]);
		} else if (r == 闱) { // unoed
			s.emit ('p', [闱]);
			return i.to (d.l).emit ('g', [闱, l._n [d.id]]);
		} else if (r == 闭) { // picked up
			s.emit ('p', [闭, d]);
			return i.to (d.l).emit ('g', [闭, l._n [d.id]]);
		} else if (r == 问) { // invalid turn
			s.emit ('p', [问]);
			return i.to (d.l).emit ('g', [问, l._n [d.id]]);
		} else if (r == 闯) { // played card
			s.emit ('p', [闯, cardtostring (d)]);
			return i.to (d.l).emit ('g', [闯, l._n [d.id], x]);
		} else if (r == 闰) { // won
			s.emit ('p', [闰]);
			return i.to (d.l).emit ('g', [闰, l._n [d.id]]);
		}
		i.emit ('e', 'error hard');
	}
}